sources:
  fluentbit:
    type: socket
    address: 0.0.0.0:24224
    mode: tcp

transforms:
  # Transformation pour les métriques
  metrics_processing:
    type: remap
    inputs:
      - fluentbit
    source: |
      # Filtrer les métriques
      if starts_with(.tag, "metrics.") {
        .host = .host || "unknown"
        .service = "system" # Ou extraire depuis une source si disponible
        .metric_name = replace(.tag, "metrics.", "") # Ex. "disk", "cpu", "mem"
        
        # Extraire la valeur de la métrique
        parsed, err = parse_json(to_string(.message) || "{}")
        .metric_value = if err == null && parsed.value != null {
          to_float(parsed.value) || 0.0
        } else {
          0.0
        }
        
        # Timestamp
        .timestamp = if err == null && parsed.timestamp != null {
          parse_timestamp!(parsed.timestamp, "%Y-%m-%dT%H:%M:%S.%fZ") || now()
        } else {
          now()
        }
        
        # Tags (ex. cpu_core, disk_name)
        .tags = if err == null { parsed.tags || {} } else { {} }
      } else {
        # Ignorer les non-métriques
        null
      }

  # Transformation pour les logs
  logs_processing:
    type: remap
    inputs:
      - fluentbit
    source: |
      # Filtrer les logs
      if starts_with(.tag, "logs.") {
        .host = .host || "unknown"
        .service = "app" # Ou extraire depuis une source si disponible
        .tag = replace(.tag, "logs.", "") # Ex. "text"
        
        # Parser JSON ou non-JSON
        raw_json, err = to_string(.message)
        parsed, err = parse_json(raw_json || "{}")
        
        # Timestamp
        .timestamp = if err == null && parsed.timestamp != null {
          parse_timestamp!(parsed.timestamp, "%Y-%m-%dT%H:%M:%S.%fZ") || now()
        } else if .time != null {
          parse_timestamp!(.time, "%Y-%m-%d %H:%M:%S") || now()
        } else {
          now()
        }
        
        # Champs logs
        .level = if err == null && parsed.level != null {
          parsed.level
        } else if .level != null {
          .level
        } else {
          "unknown"
        }
        .message = if err == null && parsed.message != null {
          parsed.message
        } else {
          .message || ""
        }
        .tags = if err == null { parsed.tags || {} } else { {} }
      } else {
        # Ignorer les non-logs
        null
      }

sinks:
  metrics_clickhouse:
    type: clickhouse
    inputs:
      - metrics_processing
    endpoint: http://89.116.38.238:8123
    database: default
    table: metrics_log
    compression: gzip
    skip_unknown_fields: true
    date_time_best_effort: true
    buffer:
      type: memory
      max_events: 1000
      when_full: block
    encoding:
      only_fields:
        - timestamp
        - host
        - service
        - metric_name
        - metric_value
        - tags

  logs_clickhouse:
    type: clickhouse
    inputs:
      - logs_processing
    endpoint: http://89.116.38.238:8123
    database: default
    table: logs_text
    compression: gzip
    skip_unknown_fields: true
    date_time_best_effort: true
    buffer:
      type: memory
      max_events: 1000
      when_full: block
    encoding:
      only_fields:
        - timestamp
        - host
        - service
        - level
        - message
        - tags

  # Sink pour RAG (futur)
  # rag_http:
  #   type: http
  #   inputs:
  #     - logs_processing
  #   uri: http://localhost:5000/embedding
  #   method: post
  #   encoding:
  #     codec: json
  #     only_fields:
  #       - message
  #       - tags
  #   healthcheck: true
  #   buffer:
  #     type: memory
  #     max_events: 500
  #     when_full: block