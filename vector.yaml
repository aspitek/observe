sources:
  fluentbit:
    type: socket
    address: 0.0.0.0:24224
    mode: tcp

transforms:
  basic_processing:
    type: remap
    inputs:
      - fluentbit
    source: |
      # Assure que tag et hostname existent
      .tag = .tag || "unknown"
      .hostname = .host || "unknown"

      # Convertir message en string JSON (sécurisé)
      raw_json, err = to_string(.message)
      .raw_json = if err == null { raw_json } else { "" }

      # Parser JSON pour extraire champs clés
      parsed, err = parse_json(.raw_json)

      # Timestamp avec fallback now()
      .timestamp = if err == null && parsed.timestamp != null {
        parse_timestamp!(parsed.timestamp, "%Y-%m-%dT%H:%M:%S.%fZ") || now()
      } else {
        now()
      }

      # Extraction champs optionnels utiles pour analytique
      .level = if err == null && parsed.level != null { parsed.level } else { "unknown" }
      .message = if err == null && parsed.message != null { parsed.message } else { "" }
      .service = if err == null && parsed.service != null { parsed.service } else { "unknown" }


sinks:
  clickhouse:
    type: clickhouse
    inputs:
      - basic_processing
    endpoint: http://89.116.38.238:8123
    database: default
    table: logs
    compression: gzip
    skip_unknown_fields: true
    date_time_best_effort: true
    buffer:
      type: memory
      max_events: 1000
      when_full: block
    encoding:
      only_fields:
        - timestamp
        - tag
        - hostname
        - level
        - message
        - service
        - raw_json

  # rag_http:
  #   type: http
  #   inputs:
  #     - basic_processing
  #   uri: http://localhost:5000/embedding  # URL de ton service embedding + Qdrant
  #   method: post
  #   encoding:
  #     codec: json
  #   healthcheck: true
  #   buffer:
  #     type: memory
  #     max_events: 500
  #     when_full: block
